#pragma kernel CSInstancedRenderingGrassInstantiationKernel

// Result buffer
RWStructuredBuffer<float4x4> gpuiInstanceData;

// Input buffers
RWStructuredBuffer<uint> detailMapData;
RWStructuredBuffer<float> heightMapData;

uniform uint detailResolution;
uniform uint heightResolution;
uniform float3 startPosition;
uniform float3 terrainSize;
uniform float4 detailScale; // Usage: [minWidth, maxWidth, minHeight, maxHeight]
uniform float4 detailAndHeightMapSize; // Usage: [detailMapWidth, detailMapHeight, heightMapWidth, heightMapHeight]

uniform Texture2D<float4> healthyDryNoiseTexture;
uniform SamplerState samplerhealthyDryNoiseTexture;
uniform float noiseSpread;
uniform float detailUniqueValue;

#include "Include/DataModel.compute"
#include "Include/Matrix.compute"
#include "Include/Random.compute"
#include "Include/Terrain.compute"

uint FixBounds(uint value, uint max, uint failValue)
{
    if(value >= max)
        return failValue;
    return value;
}

[numthreads(32, 1, 32)]
void CSInstancedRenderingGrassInstantiationKernel(uint3 id : SV_DispatchThreadID)
{
    // Check if out of terrain detail size 
    if (id.x >= uint(detailAndHeightMapSize.x))
        return;
    if (id.z >= uint(detailAndHeightMapSize.y))
        return;

    // Get detail index on maps
    uint detailIndex = id.x + id.z * detailAndHeightMapSize.x;
    
    // Get detail count
    uint detailCount = detailMapData[detailIndex];

    // Skip if no detail
    if(detailCount == 0)
        return;
    
    // Get heightMap info
    uint heightDataSize = detailAndHeightMapSize.z * detailAndHeightMapSize.w;
    float detailHeightMapScale = (heightResolution - 1.0) / detailResolution;
    
    // Convert to world coordinates
    float multiplierX = terrainSize.x / float(detailResolution);
    float multiplierZ = terrainSize.z / float(detailResolution);

    // Find data index 
    uint dataIndex = 0;
    for (uint a = 0; a < detailIndex; a++)
    {
        dataIndex += detailMapData[a];
    }

    // Set corner position
    float3 position = float3(float(id.x) * multiplierX + startPosition.x, startPosition.y, float(id.z) * multiplierZ + startPosition.z);

    //uint textureWidth, textureHeight;
    //healthyDryNoiseTexture.GetDimensions(textureWidth, textureHeight);
    
    // Loop for the amount of grass
    for (uint i = dataIndex; i < dataIndex + detailCount; i++)
    {
        float multiplier = (i - dataIndex + 1) * abs(detailUniqueValue);
        float2 randomPoint = randomFloat2(float2((position.x * multiplier), position.z));
        float randomRotation = randomFloat((position.x * multiplier) + position.z);
        //float randomScale = randomFloat((randomPoint.x + randomPoint.y) * multiplier);

        
        // Get heights around position 
        float2 heightPoint = float2((float(id.x) + randomPoint.x) * detailHeightMapScale, (float(id.z) + randomPoint.y) * detailHeightMapScale);
        uint heightIndex = floor(heightPoint.x) + floor(heightPoint.y) * detailAndHeightMapSize.z;
        float leftBottomH = heightMapData[heightIndex];
        float leftTopH = heightMapData[FixBounds(heightIndex + detailAndHeightMapSize.z, heightDataSize, heightIndex)];
        float rightBottomH = heightMapData[heightIndex + 1];
        float rightTopH = heightMapData[FixBounds(heightIndex + detailAndHeightMapSize.z + 1, heightDataSize, heightIndex)];
        
        // Set grass position
        float sampledHeight = SampleHeight(frac(heightPoint), leftBottomH, leftTopH, rightBottomH, rightTopH);
        float3 grassPosition = float3(position.x + (randomPoint.x * multiplierX), position.y + sampledHeight * terrainSize.y, position.z + (randomPoint.y * multiplierZ));
                
        // Calculate random scale
        //float randomScale = healthyDryNoiseTexture.Load(int3((float(id.x) / float(detailResolution)) * 56.0, (float(id.z) / float(detailResolution)) * 56.0, 0)).r;
        //float div364 = 256.0 / float((int) 32.0);
        float div364 = 8.0;
        float4 posterize364 = (floor(healthyDryNoiseTexture.SampleLevel(samplerhealthyDryNoiseTexture, ((grassPosition.xz * 0.05) * noiseSpread), 0) * div364) / div364);
        float randomScale = 1 - saturate(sqrt((posterize364.r * posterize364.g * posterize364.b)));

        //float randomScale = healthyDryNoiseTexture.SampleLevel(sampler_healthyDryNoiseTexture, grassPosition.xz, 0).r;
        float xzScale = detailScale[0] + ((detailScale[1] - detailScale[0]) * randomScale);
        float yScale = detailScale[2] + ((detailScale[3] - detailScale[2]) * randomScale);
        float3 scale = float3(xzScale, yScale, xzScale);

        // Calculate normal
        float3 normal = ComputeNormals(leftBottomH, leftTopH, rightBottomH, heightResolution / (terrainSize.x / terrainSize.y));
        
        // Calculate random rotation
        float4 q = FromToRotation(vector3Up, normal);
        float4 q2 = AngleAxis(vector3Up, radians(randomRotation * 360));
        float4x4 rotation = SetMatrixRotationWithQuaternion(identityMatrix, QuatMul(q, q2));

        // Add detail 
        gpuiInstanceData[i] = TRS(grassPosition, rotation, scale);
    }
}