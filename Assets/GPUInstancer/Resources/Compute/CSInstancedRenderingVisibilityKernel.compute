#pragma kernel CSInstancedRenderingVisibilityKernelLOD0
#pragma kernel CSInstancedRenderingVisibilityKernelLOD1
#pragma kernel CSInstancedRenderingVisibilityKernelLOD2
#pragma kernel CSInstancedRenderingVisibilityKernelLOD3
#pragma kernel CSInstancedRenderingVisibilityKernelLOD4
#pragma kernel CSInstancedRenderingVisibilityKernelLOD0Shadow
#pragma kernel CSInstancedRenderingVisibilityKernelLOD1Shadow
#pragma kernel CSInstancedRenderingVisibilityKernelLOD2Shadow
#pragma kernel CSInstancedRenderingVisibilityKernelLOD3Shadow
#pragma kernel CSInstancedRenderingVisibilityKernelLOD4Shadow

AppendStructuredBuffer<uint> gpuiTransformationMatrix_LOD0;
AppendStructuredBuffer<uint> gpuiTransformationMatrix_LOD1;
AppendStructuredBuffer<uint> gpuiTransformationMatrix_LOD2;
AppendStructuredBuffer<uint> gpuiTransformationMatrix_LOD3;
AppendStructuredBuffer<uint> gpuiTransformationMatrix_LOD4;
AppendStructuredBuffer<uint> gpuiTransformationMatrix_Shadow;
RWStructuredBuffer<float4x4> gpuiInstanceData;

uniform float4x4 mvpMartix;
uniform float3 boundsCenter;
uniform float3 boundsExtents;
uniform bool isFrustumCulling;
uniform float maxDistance;
uniform float shadowDistance;
uniform float3 camPos;
uniform float frustumOffset;
uniform float4 lodSizes; // usage: {lod0, lod1, lod2, lod3} in world units.
                         //        Will append to lod4 only if screen size of object is greater
                         //        than all x, y, z, and w - but still smaller than maxDistance.
uniform float frustumHeight;

#include "Include/Camera.compute" 

inline bool IsAppending(uint3 id, out float dist, out bool culled)
{
    uint numStructs = 0;
    uint strideSize = 0;
    dist = 0;
    culled = false;
    
    // Calculate buffer data and cull if instance exceeds buffer limit
    gpuiInstanceData.GetDimensions(numStructs, strideSize);
    if (id.x >= numStructs)
        return false;
    
    float3 scale = float3(length(gpuiInstanceData[id.x]._11_12_13), length(gpuiInstanceData[id.x]._21_22_23), length(gpuiInstanceData[id.x]._31_32_33));
    
    // Cull if scale is zero    
    if (scale.x == 0 || scale.y == 0 || scale.z == 0)
        return false;
    
    // Test for distance culling 
    dist = abs(distance(gpuiInstanceData[id.x]._14_24_34, camPos));
    if (dist >= maxDistance)
        return false;
        
	// Test for frustum and/or occlusion culling
    if (isFrustumCulling)
        culled = IsCulled(gpuiInstanceData[id.x], mvpMartix, boundsCenter, boundsExtents, frustumOffset, isFrustumCulling);

    return true;
}

[numthreads(1024, 1, 1)]
void CSInstancedRenderingVisibilityKernelLOD0(uint3 id : SV_DispatchThreadID)
{
    float dist = 0;
    bool culled = false;

    if (IsAppending(id, dist, culled))
    {
        if (culled)
            return;
        gpuiTransformationMatrix_LOD0.Append(id.x);
    }
}

[numthreads(1024, 1, 1)]
void CSInstancedRenderingVisibilityKernelLOD1(uint3 id : SV_DispatchThreadID)
{
    float dist = 0;
    bool culled = false;

    if (IsAppending(id, dist, culled))
    {
        if (culled)
            return;
        float size = (boundsExtents.x + boundsExtents.y + boundsExtents.z) / (frustumHeight * dist);

        if (lodSizes.x >= 0 && size > lodSizes.x)
            gpuiTransformationMatrix_LOD0.Append(id.x);
        else if (lodSizes.y >= 0 && size > lodSizes.y)
            gpuiTransformationMatrix_LOD1.Append(id.x);
    }
}

[numthreads(1024, 1, 1)]
void CSInstancedRenderingVisibilityKernelLOD2(uint3 id : SV_DispatchThreadID)
{
    float dist = 0;
    bool culled = false;

    if (IsAppending(id, dist, culled))
    {
        if (culled)
            return;
        float size = (boundsExtents.x + boundsExtents.y + boundsExtents.z) / (frustumHeight * dist);

        if (lodSizes.x >= 0 && size > lodSizes.x)
            gpuiTransformationMatrix_LOD0.Append(id.x);
        else if (lodSizes.y >= 0 && size > lodSizes.y)
            gpuiTransformationMatrix_LOD1.Append(id.x);
        else if (lodSizes.z >= 0 && size > lodSizes.z)
            gpuiTransformationMatrix_LOD2.Append(id.x);
    }
}

[numthreads(1024, 1, 1)]
void CSInstancedRenderingVisibilityKernelLOD3(uint3 id : SV_DispatchThreadID)
{
    float dist = 0;
    bool culled = false;

    if (IsAppending(id, dist, culled))
    {
        if (culled)
            return;
        float size = (boundsExtents.x + boundsExtents.y + boundsExtents.z) / (frustumHeight * dist);

        if (lodSizes.x >= 0 && size > lodSizes.x)
            gpuiTransformationMatrix_LOD0.Append(id.x);
        else if (lodSizes.y >= 0 && size > lodSizes.y)
            gpuiTransformationMatrix_LOD1.Append(id.x);
        else if (lodSizes.z >= 0 && size > lodSizes.z)
            gpuiTransformationMatrix_LOD2.Append(id.x);
        else if (lodSizes.w >= 0 && size > lodSizes.w)
            gpuiTransformationMatrix_LOD3.Append(id.x);
    }
}

[numthreads(1024, 1, 1)]
void CSInstancedRenderingVisibilityKernelLOD4(uint3 id : SV_DispatchThreadID)
{
    float dist = 0;
    bool culled = false;

    if (IsAppending(id, dist, culled))
    {
        if (culled)
            return;
        float size = (boundsExtents.x + boundsExtents.y + boundsExtents.z) / (frustumHeight * dist);

        if (lodSizes.x >= 0 && size > lodSizes.x)
            gpuiTransformationMatrix_LOD0.Append(id.x);
        else if (lodSizes.y >= 0 && size > lodSizes.y)
            gpuiTransformationMatrix_LOD1.Append(id.x);
        else if (lodSizes.z >= 0 && size > lodSizes.z)
            gpuiTransformationMatrix_LOD2.Append(id.x);
        else if (lodSizes.w >= 0 && size > lodSizes.w)
            gpuiTransformationMatrix_LOD3.Append(id.x);
        else if (lodSizes.w > 0) // append to lod4 if only other lod distances are defined 
            gpuiTransformationMatrix_LOD4.Append(id.x);
    }
}


[numthreads(1024, 1, 1)]
void CSInstancedRenderingVisibilityKernelLOD0Shadow(uint3 id : SV_DispatchThreadID)
{
    float dist = 0;
    bool culled = false;

    if (IsAppending(id, dist, culled))
    {
        // Handle shadows if frustum/occlusion culled
        if (culled)
        {
            if (shadowDistance > 0 && dist <= shadowDistance)
                gpuiTransformationMatrix_Shadow.Append(id.x);
            return;
        }

        gpuiTransformationMatrix_LOD0.Append(id.x);
    }
}

[numthreads(1024, 1, 1)]
void CSInstancedRenderingVisibilityKernelLOD1Shadow(uint3 id : SV_DispatchThreadID)
{
    float dist = 0;
    bool culled = false;

    if (IsAppending(id, dist, culled))
    {
        // Handle shadows if frustum/occlusion culled
        if (culled)
        {
            if (shadowDistance > 0 && dist <= shadowDistance)
                gpuiTransformationMatrix_Shadow.Append(id.x);
            return;
        }
        
        float size = (boundsExtents.x + boundsExtents.y + boundsExtents.z) / (frustumHeight * dist);

        if (lodSizes.x >= 0 && size > lodSizes.x)
            gpuiTransformationMatrix_LOD0.Append(id.x);
        else if (lodSizes.y >= 0 && size > lodSizes.y)
            gpuiTransformationMatrix_LOD1.Append(id.x);
    }
}

[numthreads(1024, 1, 1)]
void CSInstancedRenderingVisibilityKernelLOD2Shadow(uint3 id : SV_DispatchThreadID)
{
    float dist = 0;
    bool culled = false;

    if (IsAppending(id, dist, culled))
    {
        // Handle shadows if frustum/occlusion culled
        if (culled)
        {
            if (shadowDistance > 0 && dist <= shadowDistance)
                gpuiTransformationMatrix_Shadow.Append(id.x);
            return;
        }
        
        float size = (boundsExtents.x + boundsExtents.y + boundsExtents.z) / (frustumHeight * dist);

        if (lodSizes.x >= 0 && size > lodSizes.x)
            gpuiTransformationMatrix_LOD0.Append(id.x);
        else if (lodSizes.y >= 0 && size > lodSizes.y)
            gpuiTransformationMatrix_LOD1.Append(id.x);
        else if (lodSizes.z >= 0 && size > lodSizes.z)
            gpuiTransformationMatrix_LOD2.Append(id.x);
    }
}

[numthreads(1024, 1, 1)]
void CSInstancedRenderingVisibilityKernelLOD3Shadow(uint3 id : SV_DispatchThreadID)
{
    float dist = 0;
    bool culled = false;

    if (IsAppending(id, dist, culled))
    {
        // Handle shadows if frustum/occlusion culled
        if (culled)
        {
            if (shadowDistance > 0 && dist <= shadowDistance)
                gpuiTransformationMatrix_Shadow.Append(id.x);
            return;
        }
        
        float size = (boundsExtents.x + boundsExtents.y + boundsExtents.z) / (frustumHeight * dist);

        if (lodSizes.x >= 0 && size > lodSizes.x)
            gpuiTransformationMatrix_LOD0.Append(id.x);
        else if (lodSizes.y >= 0 && size > lodSizes.y)
            gpuiTransformationMatrix_LOD1.Append(id.x);
        else if (lodSizes.z >= 0 && size > lodSizes.z)
            gpuiTransformationMatrix_LOD2.Append(id.x);
        else if (lodSizes.w >= 0 && size > lodSizes.w)
            gpuiTransformationMatrix_LOD3.Append(id.x);
    }
}


[numthreads(1024, 1, 1)]
void CSInstancedRenderingVisibilityKernelLOD4Shadow(uint3 id : SV_DispatchThreadID)
{
    float dist = 0;
    bool culled = false;

    if (IsAppending(id, dist, culled))
    {
        // Handle shadows if frustum/occlusion culled
        if (culled)
        {
            if (shadowDistance > 0 && dist <= shadowDistance)
                gpuiTransformationMatrix_Shadow.Append(id.x);
            return;
        }
        
        float size = (boundsExtents.x + boundsExtents.y + boundsExtents.z) / (frustumHeight * dist);

        if (lodSizes.x >= 0 && size > lodSizes.x)
            gpuiTransformationMatrix_LOD0.Append(id.x);
        else if (lodSizes.y >= 0 && size > lodSizes.y)
            gpuiTransformationMatrix_LOD1.Append(id.x);
        else if (lodSizes.z >= 0 && size > lodSizes.z)
            gpuiTransformationMatrix_LOD2.Append(id.x);
        else if (lodSizes.w >= 0 && size > lodSizes.w)
            gpuiTransformationMatrix_LOD3.Append(id.x);
        else if (lodSizes.w > 0) // append to lod4 if only other lod distances are defined 
            gpuiTransformationMatrix_LOD4.Append(id.x);
    }
}